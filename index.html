<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>睿康的批量添加水印工具</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 全局样式 */
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(120deg, #f0f4f8, #cfe0f5);
            margin: 0;
            padding: 20px;
            color: #333;
        }
        #watermark-tool {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            box-sizing: border-box;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        #watermark-tool h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        /* 自定义文件选择按钮样式 */
        #custom-file-button {
            width: 100%;
            padding: 15px;
            background-color: #3498db;
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            margin: 10px 0;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.2s;
        }
        #custom-file-button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        /* 主内容区域 */
        #main-content {
            display: flex;
            flex-direction: row;
            gap: 20px;
            min-height: 500px;
        }
        /* 控件区域样式 */
        #left-controls, #right-controls {
            flex: 0 0 250px;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        /* 调整预览区域的宽度 */
        #preview-container {
            flex: 1;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f1f3f5;
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .control-group h3 {
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
            color: #2c3e50;
        }
        .control-group h4 {
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #34495e;
        }
        .control-group label {
            display: block;
            margin: 10px 0 5px;
            font-weight: 500;
            color: #2c3e50;
        }
        .control-group input[type="range"],
        .control-group input[type="color"],
        .control-group select,
        .control-group input[type="number"] {
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }
        .slider-value {
            display: inline-block;
            width: 50px;
            text-align: right;
            margin-left: 10px;
            font-weight: bold;
        }
        /* 调整输入框和单位符号的位置 */
        .input-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .input-group input[type="number"] {
            width: 70px;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #bdc3c7;
            border-radius: 4px 0 0 4px;
        }
        .input-group span {
            padding: 8px 12px;
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-left: none;
            border-radius: 0 4px 4px 0;
            color: #7f8c8d;
        }
        /* 按钮样式 */
        .action-button {
            width: 100%;
            padding: 12px;
            background-color: #2ecc71;
            border: none;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            margin: 5px 0;
            border-radius: 6px;
            transition: background-color 0.3s, transform 0.2s;
        }
        .action-button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }
        .small-button {
            padding: 10px 15px;
            margin: 5px 0;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            transition: background-color 0.3s, transform 0.2s;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #ecf0f1;
            color: #2c3e50;
        }
        .small-button.active {
            background-color: #3498db;
            color: #fff;
        }
        .small-button:hover {
            background-color: #bdc3c7;
            transform: translateY(-2px);
        }
        /* 进度条样式 */
        #progress-bar {
            width: 100%;
            background-color: #ecf0f1;
            margin: 15px 0;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            display: none;
            position: relative;
            z-index: 1;
        }
        #progress-bar-inner {
            height: 100%;
            width: 0%;
            background-color: #2ecc71;
            transition: width 0.3s;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            animation: pulseProgress 1.5s infinite;
        }
        @keyframes pulseProgress {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        #loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(52, 152, 219, 0.3);
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            transform: translate(-50%, -50%);
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        /* Swiper 样式 */
        .swiper-container {
            width: 100%;
            height: 100%;
        }
        .swiper-slide {
            display: flex;
            justify-content: center;
            align-items: center;
            height: auto;
        }
        .swiper-pagination {
            position: relative;
            margin-top: 15px;
        }
        /* Canvas 样式 */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        /* 水印预览样式 */
        #watermark-preview-container {
            display: flex;
            overflow-x: auto;
            border: 1px solid #bdc3c7;
            padding: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        .watermark-preview {
            width: 60px;
            height: 60px;
            margin-right: 10px;
            cursor: pointer;
            border: 2px solid #ecf0f1;
            border-radius: 6px;
            transition: border-color 0.3s, transform 0.2s;
            object-fit: cover;
        }
        .watermark-preview:hover {
            border-color: #3498db;
            transform: scale(1.05);
        }
        .watermark-preview.selected {
            border-color: #3498db;
            box-shadow: 0 0 0 2px #3498db;
        }
        /* 折叠部分样式 */
        .collapsible {
            background-color: #ecf0f1;
            cursor: pointer;
            padding: 12px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 16px;
            margin-bottom: 10px;
            transition: background-color 0.3s;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .collapsible:after {
            content: '\002B';
            font-weight: bold;
            float: right;
            margin-left: 5px;
            transition: transform 0.3s;
        }
        .collapsible.active:after {
            content: "\2212";
            transform: rotate(180deg);
        }
        .collapsible:hover {
            background-color: #bdc3c7;
        }
        .active {
            background-color: #bdc3c7;
        }
        /* 定义隐藏和显示时的样式 */
        .content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out;
            background-color: #f8f9fa;
            border-radius: 0 0 6px 6px;
        }
        .content.show {
            max-height: 1000px;
            padding: 15px;
            border: 1px solid #ecf0f1;
            border-top: none;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        /* 水印库列表样式 */
        #watermark-list {
            margin-top: 15px;
        }
        .watermark-item {
            background: #ffffff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .watermark-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        .watermark-thumbnail {
            width: 60px;
            height: 60px;
            margin-right: 15px;
            border: 1px solid #ecf0f1;
            border-radius: 6px;
            object-fit: cover;
        }
        .watermark-item button {
            margin-left: auto;
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .watermark-item button:first-of-type {
            background-color: #e74c3c;
            color: white;
        }
        .watermark-item button:last-of-type {
            background-color: #3498db;
            color: white;
            margin-left: 10px;
        }
        .watermark-item button:hover {
            opacity: 0.9;
        }
        /* 绘制水印画布样式 */
        #drawing-canvas {
            border: 2px solid #3498db;
            border-radius: 8px;
            background-color: #fff;
            margin-bottom: 15px;
            cursor: crosshair;
        }
        /* 文字水印输入框样式 */
        #text-watermark-input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            box-sizing: border-box;
            margin-bottom: 15px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
        }
        /* 水印库管理按钮组样式 */
        .button-group {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .button-group .small-button {
            flex: 1;
            margin-right: 10px;
        }
        .button-group .small-button:last-child {
            margin-right: 0;
        }
        /* 隐藏的文件选择控件 */
        #watermark-upload-input,
        #preset-import-input {
            display: none;
        }
        /* 模态窗口样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }
        .close-modal:hover,
        .close-modal:focus {
            color: #000;
            text-decoration: none;
        }
        /* 帮助按钮样式 */
        #help-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: #3498db;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.3s;
            animation: pulse 2s infinite;
        }
        #help-button:hover {
            background-color: #2980b9;
            transform: scale(1.1);
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.7);
            }
            70% {
                transform: scale(1.1);
                box-shadow: 0 0 0 10px rgba(52, 152, 219, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0);
            }
        }
        /* 快捷键提示样式 */
        #shortcut-tips {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(52, 152, 219, 0.9);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        #shortcut-tips.show-shortcut-tips {
            opacity: 1;
            transform: translateY(0);
        }
        #shortcut-tips:hover {
            background-color: rgba(41, 128, 185, 0.9);
        }
        /* 响应式设计 */
        @media (max-width: 768px) {
            #main-content {
                flex-direction: column;
            }
            #left-controls, #right-controls {
                flex: 0 0 auto;
                width: 100%;
            }
            #preview-container {
                order: -1;
                margin-bottom: 20px;
            }
            .control-group h3, .control-group label {
                font-size: 16px;
            }
            .action-button, .small-button {
                font-size: 14px;
                padding: 12px;
            }
            #help-button {
                width: 50px;
                height: 50px;
                bottom: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- 帮助按钮及快捷键提示容器 -->
    <div id="help-container">
        <!-- 快捷键提示容器 -->
        <div id="shortcut-tips" class="shortcut-tips">
            <span id="tip-text">快捷键提示</span>
        </div>
        <!-- 帮助按钮 -->
        <button id="help-button" class="help-button">
            <i class="fas fa-question" style="color: white; font-size: 24px;"></i>
        </button>
    </div>

    <!-- 帮助模态窗口 -->
    <div id="help-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>使用说明</h2>
            <p>欢迎使用批量添加水印工具！以下是使用指南：</p>
            <ol>
                <li>点击"选择图片"按钮，上传您要添加水印的图片。</li>
                <li>在左侧调整水印的参数，包括位置、缩放比例、旋转角度、偏移和透明度。</li>
                <li>在右侧可以选择水印、调整颜色、保存和加载预设。</li>
                <li>您可以直接在图片上拖动水印，调整其位置、大小和旋转角度。</li>
                <li>完成设置后，可以下载当前照片或所有照片。</li>
            </ol>
            <p>如果您有任何疑问，请参阅使用手册。</p>
            <button id="view-manual-button" class="action-button">查看使用手册</button>
        </div>
    </div>

    <div id="watermark-tool">
        <h1><i class="fas fa-stamp"></i> 睿康的批量添加水印工具</h1>
        <!-- 隐藏的文件选择控件 -->
        <input type="file" id="image-input" accept="image/*" multiple style="display:none;">
        <!-- 自定义文件选择按钮 -->
        <button id="custom-file-button"><i class="fas fa-file-upload"></i> 选择图片</button>

        <!-- 水印库管理 -->
        <div id="watermark-library">
            <button type="button" class="collapsible active"><i class="fas fa-images"></i> 水印库管理</button>
            <div class="content show">
                <!-- 水印库管理工具 -->
                <div class="button-group">
                    <button id="upload-watermark-button" class="small-button"><i class="fas fa-upload"></i> 上传水印</button>
                    <button id="draw-watermark-button" class="small-button"><i class="fas fa-paint-brush"></i> 绘制水印</button>
                    <button id="text-watermark-button" class="small-button"><i class="fas fa-font"></i> 文字水印</button>
                </div>
                <!-- 绘制水印的弹窗 -->
                <div id="draw-watermark-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-modal">&times;</span>
                        <canvas id="drawing-canvas" width="300" height="150"></canvas>
                        <button id="save-drawing-button" class="small-button"><i class="fas fa-save"></i> 保存绘制水印</button>
                        <button id="cancel-drawing-button" class="small-button"><i class="fas fa-times"></i> 取消</button>
                    </div>
                </div>
                <!-- 文字水印的弹窗 -->
                <div id="text-watermark-modal" class="modal">
                    <div class="modal-content">
                        <span class="close-modal">&times;</span>
                        <label for="text-watermark-input">输入文字：</label>
                        <input type="text" id="text-watermark-input" placeholder="请输入水印文字">
                        <label for="font-select">选择字体：</label>
                        <select id="font-select">
                            <option value="Arial">Arial</option>
                            <option value="Handlee">Handlee</option>
                            <!-- 添加其他字体选项 -->
                        </select>
                        <label for="font-size-input">字体大小：</label>
                        <input type="number" id="font-size-input" value="48" min="10" max="200">
                        <button id="save-text-button" class="small-button"><i class="fas fa-save"></i> 保存文字水印</button>
                        <button id="cancel-text-button" class="small-button"><i class="fas fa-times"></i> 取消</button>
                    </div>
                </div>
                <div id="watermark-list">
                    <!-- 水印项目将在这里动态添加 -->
                </div>
                <!-- 隐藏的文件选择控件（用于上传水印） -->
                <input type="file" id="watermark-upload-input" accept="image/*">
            </div>
        </div>

        <!-- 进度条 -->
        <div id="progress-bar">
            <div id="progress-bar-inner"></div>
            <div id="loading-spinner"></div>
        </div>
        <!-- 主内容区域 -->
        <div id="main-content">
            <!-- 左侧：参数调整 -->
            <div id="left-controls">
                <!-- 参数调整的控件 -->
                <div class="control-group">
                    <h3><i class="fas fa-sliders-h"></i> 调整参数</h3>
                    <label for="position-select">水印位置：</label>
                    <select id="position-select">
                        <option value="bottom-center">底部居中</option>
                        <option value="bottom-left">左下角</option>
                        <option value="bottom-right">右下角</option>
                        <option value="top-center">顶部居中</option>
                        <option value="top-left">左上角</option>
                        <option value="top-right">右上角</option>
                    </select>
                    <label for="scale-slider">缩放比例：</label>
                    <div class="input-group">
                        <input type="number" id="scale-input" value="20" min="10" max="100">
                        <span>%</span>
                    </div>
                    <input type="range" id="scale-slider" min="10" max="100" value="50">
                    <label for="rotation-slider">旋转角度：</label>
                    <div class="input-group">
                        <input type="number" id="rotation-input" value="0" min="-180" max="180">
                        <span>°</span>
                    </div>
                    <input type="range" id="rotation-slider" min="-180" max="180" value="0">
                    <label for="offset-x-slider">水平偏移：</label>
                    <div class="input-group">
                        <input type="number" id="offset-x-input" value="0" min="-2000" max="2000">
                        <span>px</span>
                    </div>
                    <input type="range" id="offset-x-slider" min="-2000" max="2000" value="0">
                    <label for="offset-y-slider">垂直偏移：</label>
                    <div class="input-group">
                        <input type="number" id="offset-y-input" value="0" min="-2000" max="2000">
                        <span>px</span>
                    </div>
                    <input type="range" id="offset-y-slider" min="-2000" max="2000" value="0">
                    <label for="opacity-slider">透明度：</label>
                    <div class="input-group">
                        <input type="number" id="opacity-input" value="100" min="0" max="100">
                        <span>%</span>
                    </div>
                    <input type="range" id="opacity-slider" min="0" max="100" value="100">
                </div>
                <!-- 操作按钮 -->
                <div class="control-group">
                    <h3><i class="fas fa-cogs"></i> 操作</h3>
                    <button id="undo-button" class="small-button"><i class="fas fa-undo"></i> 撤销</button>
                    <button id="redo-button" class="small-button"><i class="fas fa-redo"></i> 还原</button>
                    <button id="download-current-button" class="action-button"><i class="fas fa-download"></i> 保存当前照片</button>
                    <button id="download-all-button" class="action-button"><i class="fas fa-cloud-download-alt"></i> 保存所有照片</button>
                </div>
            </div>
            <!-- 中间：照片查看区域 -->
            <div id="preview-container">
                <!-- Swiper 容器 -->
                <div id="canvas-container" class="swiper-container">
                    <div class="swiper-wrapper">
                        <!-- 这里动态添加每个canvas的swiper-slide -->
                    </div>
                    <!-- 添加分页器 -->
                    <div class="swiper-pagination"></div>
                </div>
            </div>
            <!-- 右侧：签名设置、预设管理 -->
            <div id="right-controls">
                <!-- 签名设置 -->
                <div class="control-group">
                    <h3><i class="fas fa-signature"></i> 签名设置</h3>
                    <label>签名颜色：</label>
                    <button id="color-black-button" class="small-button"><i class="fas fa-tint"></i> 黑色</button>
                    <button id="color-white-button" class="small-button"><i class="fas fa-tint"></i> 白色</button>
                    <label for="color-picker">自定义颜色：</label>
                    <input type="color" id="color-picker" value="#000000">
                    <label>
                        <input type="checkbox" id="shadow-checkbox">
                        添加阴影
                    </label>
                    <!-- 水印选择预览 -->
                    <h4>水印选择</h4>
                    <div id="watermark-preview-container">
                        <!-- 水印预览滑动框 -->
                    </div>
                </div>
                <!-- 预设管理 -->
                <div class="control-group">
                    <h3><i class="fas fa-save"></i> 预设管理</h3>
                    <label for="preset-name-input">预设名称：</label>
                    <input type="text" id="preset-name-input" placeholder="输入预设名称">
                    <div class="button-group">
                        <button id="save-preset-button" class="small-button"><i class="fas fa-save"></i> 保存预设</button>
                        <button id="export-preset-button" class="small-button"><i class="fas fa-file-export"></i> 导出预设</button>
                    </div>
                    <label for="preset-select">选择预设：</label>
                    <select id="preset-select">
                        <option value="">选择预设</option>
                    </select>
                    <div class="button-group">
                        <button id="load-preset-button" class="small-button"><i class="fas fa-folder-open"></i> 加载预设</button>
                        <button id="delete-preset-button" class="small-button"><i class="fas fa-trash-alt"></i> 删除预设</button>
                        <button id="import-preset-button" class="small-button"><i class="fas fa-file-import"></i> 导入预设</button>
                    </div>
                    <input type="file" id="preset-import-input" accept=".json">
                    <button id="apply-previous-button" class="small-button"><i class="fas fa-copy"></i> 使用上一张照片设置</button>
                    <button id="apply-all-button" class="small-button"><i class="fas fa-clone"></i> 应用到全部</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 引入 JSZip 和 FileSaver.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- 引入 Swiper 的 JS -->
    <script src="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.js"></script>
    <!-- 引入 SortableJS 的 JS -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <!-- 引入 Signature Pad 的 JS -->
    <script src="https://cdn.jsdelivr.net/npm/signature_pad@4.0.0/dist/signature_pad.umd.min.js"></script>
    <!-- 引入 Hammer.js -->
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <!-- 引入 Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.6.0/fabric.min.js"></script>

    <script>
            // 全局变量
            let processedImages = [];
            let imageFiles = [];
            let watermarkImages = []; // 水印图片数组
            let canvasList = [];
            let currentIndex = 0;
            let swiper;
            let actionHistory = [];
            let redoStack = [];
            let defaultWatermarkIndex = 0; // 默认水印索引

            // 初始化水印库
            updateWatermarkList();

            // 事件监听器
            document.getElementById('custom-file-button').addEventListener('click', () => {
                document.getElementById('image-input').click();
            });
            document.getElementById('image-input').addEventListener('change', function() {
                const files = this.files;
                if (files.length > 0) {
                    document.getElementById('custom-file-button').textContent = '已选择 ' + files.length + ' 张图片';
                    processImages(); // 自动开始处理
                } else {
                    document.getElementById('custom-file-button').textContent = '选择图片';
                }
            });

            document.getElementById('download-current-button').addEventListener('click', downloadCurrentImage);
            document.getElementById('download-all-button').addEventListener('click', downloadAllImages);
            document.getElementById('position-select').addEventListener('change', updatePosition);

            // 缩放比例滑块和输入框同步
            document.getElementById('scale-slider').addEventListener('input', function() {
                document.getElementById('scale-input').value = this.value;
                updateScale();
            });
            document.getElementById('scale-input').addEventListener('input', function() {
                let value = parseInt(this.value);
                if (value < 10) value = 10;
                if (value > 100) value = 100;
                this.value = value;
                document.getElementById('scale-slider').value = value;
                updateScale();
            });

            // 旋转角度滑块和输入框同步
            document.getElementById('rotation-slider').addEventListener('input', function() {
                document.getElementById('rotation-input').value = this.value;
                updateRotation();
            });
            document.getElementById('rotation-input').addEventListener('input', function() {
                let value = parseInt(this.value);
                if (value < -180) value = -180;
                if (value > 180) value = 180;
                this.value = value;
                document.getElementById('rotation-slider').value = value;
                updateRotation();
            });

            // 偏移X滑块和输入框同步
            document.getElementById('offset-x-slider').addEventListener('input', function() {
                document.getElementById('offset-x-input').value = this.value;
                updateOffsetX();
            });
            document.getElementById('offset-x-input').addEventListener('input', function() {
                let value = parseInt(this.value);
                if (value < -2000) value = -2000;
                if (value > 2000) value = 2000;
                this.value = value;
                document.getElementById('offset-x-slider').value = value;
                updateOffsetX();
            });

            // 偏移Y滑块和输入框同步
            document.getElementById('offset-y-slider').addEventListener('input', function() {
                document.getElementById('offset-y-input').value = this.value;
                updateOffsetY();
            });
            document.getElementById('offset-y-input').addEventListener('input', function() {
                let value = parseInt(this.value);
                if (value < -2000) value = -2000;
                if (value > 2000) value = 2000;
                this.value = value;
                document.getElementById('offset-y-slider').value = value;
                updateOffsetY();
            });

            // 透明度滑块和输入框同步
            document.getElementById('opacity-slider').addEventListener('input', function() {
                document.getElementById('opacity-input').value = this.value;
                updateOpacity();
            });
            document.getElementById('opacity-input').addEventListener('input', function() {
                let value = parseInt(this.value);
                if (value < 0) value = 0;
                if (value > 100) value = 100;
                this.value = value;
                document.getElementById('opacity-slider').value = value;
                updateOpacity();
            });

            document.getElementById('color-black-button').addEventListener('click', () => {
                setColorOption('#000000');
            });
            document.getElementById('color-white-button').addEventListener('click', () => {
                setColorOption('#FFFFFF');
            });
            document.getElementById('color-picker').addEventListener('input', () => {
                setColorOption(document.getElementById('color-picker').value);
            });
            document.getElementById('shadow-checkbox').addEventListener('change', function() {
                const params = canvasList[currentIndex];
                const previousShadow = params.shadowEnabled;
                params.shadowEnabled = this.checked;
                updateCurrentPreview();
                recordAction({
                    type: 'shadowChange',
                    index: currentIndex,
                    previousParams: { shadowEnabled: previousShadow }
                });
            });
            document.getElementById('apply-previous-button').addEventListener('click', applyPreviousSettings);
            document.getElementById('apply-all-button').addEventListener('click', applyToAll);
            document.getElementById('undo-button').addEventListener('click', undo);
            document.getElementById('redo-button').addEventListener('click', redo);
            document.getElementById('save-preset-button').addEventListener('click', savePreset);
            document.getElementById('load-preset-button').addEventListener('click', loadPreset);
            document.getElementById('delete-preset-button').addEventListener('click', deletePreset);
            document.getElementById('export-preset-button').addEventListener('click', exportPreset);
            document.getElementById('import-preset-button').addEventListener('click', () => {
                document.getElementById('preset-import-input').click();
            });
            document.getElementById('preset-import-input').addEventListener('change', importPreset);

            // 定义帮助模态窗口状态
            let isHelpModalOpen = false;

            // 切换帮助模态窗口并同步快捷键提示显示状态
            function toggleHelpModal() {
                const helpModal = document.getElementById('help-modal');
                isHelpModalOpen = !isHelpModalOpen;
                helpModal.style.display = isHelpModalOpen ? 'block' : 'none';

                // 根据帮助模态窗口的状态隐藏或显示快捷键提示
                const shortcutTips = document.getElementById('shortcut-tips');
                if (isHelpModalOpen) {
                    shortcutTips.classList.remove('show-shortcut-tips');
                } else {
                    shortcutTips.classList.add('show-shortcut-tips');
                }
            }

            // 帮助按钮事件
            document.getElementById('help-button').addEventListener('click', toggleHelpModal);

            // 关闭模态窗口事件
            document.querySelectorAll('.close-modal').forEach(function(elem) {
                elem.addEventListener('click', function() {
                    isHelpModalOpen = false;
                    this.parentElement.parentElement.style.display = 'none';
                    document.getElementById('shortcut-tips').classList.add('show-shortcut-tips');
                });
            });

            // 点击模态窗口外部关闭
            window.addEventListener('click', function(event) {
                if (event.target.classList.contains('modal')) {
                    isHelpModalOpen = false;
                    event.target.style.display = 'none';
                    document.getElementById('shortcut-tips').classList.add('show-shortcut-tips');
                }
            });

            // 初始化时显示快捷键提示
            document.addEventListener('DOMContentLoaded', function() {
                document.getElementById('shortcut-tips').classList.add('show-shortcut-tips');
            });

            // 查看使用手册
            document.getElementById('view-manual-button').addEventListener('click', function() {
                window.open('manual.pdf', '_blank');
            });

            // 定义提示数组
            const tips = [
            "按 H 键打开帮助页面",
            "使用 ← 和 → 键切换图片",
            "按 W、A、S、D 键移动水印",
            "按 Shift + W、A、S、D 键微调水印位置",
            "按 + 或 - 键调整水印透明度",
            "按 Shift + '+'' 或 '-' 键微调水印透明度",
            "按 [ 或 ] 键缩放水印",
            "按 Shift + [ 或 ] 键微调水印缩放",
            "按 , 或 . 键旋转水印",
            "按 Shift + , 或 . 键微调水印旋转",
            "按 B/W 键切换水印为黑色/白色",
            "按 Ctrl + S 保存当前图片",
            "按 Ctrl + Shift + S 保存所有图片",
            "按 Ctrl + U 上传图片",
            "按 Alt + U 上传水印",
            "按 Shift + P 应用当前设置到所有图片",
            "按 Ctrl + Shift + P 保存当前预设",
            "按 Ctrl + I 导入预设",
            "按 Ctrl + L 加载预设",
            "按 Ctrl + E 导出预设",
            ];

            // 获取提示元素
            const tipText = document.getElementById('tip-text');
            let currentTipIndex = 0;

            // 每隔 3 秒切换提示内容
            setInterval(() => {
                // 更新提示文本
                tipText.textContent = tips[currentTipIndex];
                currentTipIndex = (currentTipIndex + 1) % tips.length; // 循环索引

                // 添加淡入淡出效果
                tipText.classList.remove('show-shortcut-tips');
                setTimeout(() => tipText.classList.add('show-shortcut-tips'), 100); // 延时显示新提示
            }, 3000);

            // 保证快捷键提示在初始加载时显示
            document.addEventListener('DOMContentLoaded', function() {
                document.getElementById('shortcut-tips').classList.add('show-shortcut-tips');
            });
            
            function moveWatermark(deltaX, deltaY) {
                const params = canvasList[currentIndex];
                const previousOffsetX = params.offsetX;
                const previousOffsetY = params.offsetY;
                params.offsetX += deltaX;
                params.offsetY += deltaY;
                // 更新控件
                document.getElementById('offset-x-slider').value = params.offsetX;
                document.getElementById('offset-x-input').value = params.offsetX;
                document.getElementById('offset-y-slider').value = params.offsetY;
                document.getElementById('offset-y-input').value = params.offsetY;
                updateCurrentPreview();
                recordAction({
                    type: 'offsetChange',
                    index: currentIndex,
                    previousParams: {
                        offsetX: previousOffsetX,
                        offsetY: previousOffsetY
                    }
                });
            }
            function scaleWatermark(deltaPercent) {
                const params = canvasList[currentIndex];
                const previousScale = params.scale;
                let newScalePercent = params.scale * 100 + deltaPercent;
                if (newScalePercent < 10) newScalePercent = 10;
                if (newScalePercent > 100) newScalePercent = 100;
                params.scale = newScalePercent / 100;
                // 更新控件
                document.getElementById('scale-slider').value = newScalePercent;
                document.getElementById('scale-input').value = newScalePercent;
                updateCurrentPreview();
                recordAction({
                    type: 'scaleChange',
                    index: currentIndex,
                    previousParams: {
                        scale: previousScale
                    }
                });
            }

            function rotateWatermark(deltaDegrees) {
                const params = canvasList[currentIndex];
                const previousRotation = params.rotation;
                params.rotation += deltaDegrees;
                if (params.rotation < -180) params.rotation += 360;
                if (params.rotation > 180) params.rotation -= 360;
                // 更新控件
                document.getElementById('rotation-slider').value = params.rotation;
                document.getElementById('rotation-input').value = params.rotation;
                updateCurrentPreview();
                recordAction({
                    type: 'rotationChange',
                    index: currentIndex,
                    previousParams: {
                        rotation: previousRotation
                    }
                });
            }

            function adjustOpacity(deltaPercent) {
                const params = canvasList[currentIndex];
                const previousOpacity = params.opacity;
                let newOpacityPercent = params.opacity * 100 + deltaPercent;
                if (newOpacityPercent < 0) newOpacityPercent = 0;
                if (newOpacityPercent > 100) newOpacityPercent = 100;
                params.opacity = newOpacityPercent / 100;
                // 更新控件
                document.getElementById('opacity-slider').value = newOpacityPercent;
                document.getElementById('opacity-input').value = newOpacityPercent;
                updateCurrentPreview();
                recordAction({
                    type: 'opacityChange',
                    index: currentIndex,
                    previousParams: {
                        opacity: previousOpacity
                    }
                });
            }

            // 键盘事件监听器
            document.addEventListener('keydown', function(event) {
                // 忽略输入框和文本区域中的键盘事件
                if (event.target.tagName.toLowerCase() === 'input' || 
                    event.target.tagName.toLowerCase() === 'textarea') {
                    return;
                }

                const key = event.key.toLowerCase(); // 统一使用小写字符
                const isShift = event.shiftKey;
                const isCtrl = event.ctrlKey || event.metaKey;
                const isAlt = event.altKey;

                // 设置不同操作的变量
                const moveAmount = isShift ? 1 : 10;
                const scaleAmount = isShift ? 1 : 5;
                const rotateAmount = isShift ? 1 : 5;
                const opacityAmount = isShift ? 1 : 5;
                    
                // 根据键盘输入执行不同功能
                switch (key) {
                    // Ctrl + W：切换为白色水印
                    case 'w':
                        if (isCtrl && !isShift && !isAlt) {
                            event.preventDefault();
                            setColorOption('#FFFFFF');
                        } else if (!isCtrl && !isAlt) { // 上移
                            event.preventDefault();
                            moveWatermark(0, -moveAmount);
                        }
                        break;

                    // Ctrl + B：切换为黑色水印
                    case 'b':
                        if (isCtrl && !isShift && !isAlt) {
                            event.preventDefault();
                            setColorOption('#000000');
                        }
                        break;

                    // 其他移动和操作快捷键
                    case 'a': // 左移
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            moveWatermark(-moveAmount, 0);
                        }
                        break;
                    case 's': // 下移
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            moveWatermark(0, moveAmount);
                        }
                        break;
                    case 'd': // 右移
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            moveWatermark(moveAmount, 0);
                        }
                        break;

                    // 水印缩放
                    case '[': // 缩小
                    case '{': 
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            scaleWatermark(-scaleAmount);
                        }
                        break;
                    case ']': // 放大
                    case '}':
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            scaleWatermark(scaleAmount);
                        }
                        break;

                    // 水印旋转
                    case ',': // 逆时针旋转
                    case '<':
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            rotateWatermark(-rotateAmount);
                        }
                        break;
                    case '.': // 顺时针旋转
                    case '>':
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            rotateWatermark(rotateAmount);
                        }
                        break;

                    // 透明度调整
                    case '=': // 增加透明度
                    case '+':
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            adjustOpacity(opacityAmount);
                        }
                        break;
                    case '-': // 减少透明度
                    case '_':
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            adjustOpacity(-opacityAmount);
                        }
                        break;

                    // 图片切换
                    case 'arrowleft': // 上一张图片
                        event.preventDefault();
                        if (currentIndex > 0) {
                            swiper.slidePrev();
                        }
                        break;
                    case 'arrowright': // 下一张图片
                        event.preventDefault();
                        if (currentIndex < canvasList.length - 1) {
                            swiper.slideNext();
                        }
                        break;

                    // 应用设置到所有图片
                    case 'p':
                        if (isShift && !isCtrl && !isAlt) {
                            event.preventDefault();
                            applyToAll();
                        }
                        break;

                    // 打开帮助
                    case 'h':
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            toggleHelpModal();
                        }
                        break;

                    // 保存图片
                    case 's':
                        if (isCtrl && !isAlt) {
                            event.preventDefault();
                            if (isShift) {
                                downloadAllImages();
                            } else {
                                downloadCurrentImage();
                            }
                        }
                        break;

                    // 上传图片或水印
                    case 'u':
                        if (isCtrl && !isAlt) {
                            event.preventDefault();
                            document.getElementById('image-input').click();
                        } else if (isAlt && !isCtrl) {
                            event.preventDefault();
                            document.getElementById('watermark-upload-input').click();
                        }
                        break;

                    // 预设管理快捷键
                    case 'p':
                        if (isCtrl && isShift && !isAlt) {
                            event.preventDefault();
                            savePreset();
                        }
                        break;
                    case 'i':
                        if (isCtrl && isShift && !isAlt) {
                            event.preventDefault();
                            document.getElementById('preset-import-input').click();
                        }
                        break;
                    case 'l':
                        if (isCtrl && !isShift && !isAlt) {
                            event.preventDefault();
                            loadPreset();
                        }
                        break;
                    case 'e':
                        if (isCtrl && !isShift && !isAlt) {
                            event.preventDefault();
                            exportPreset();
                        }
                        break;

                    // 切换水印
                    case '0': // 切换到第10个水印
                        if (!isCtrl && !isAlt) {
                            event.preventDefault();
                            selectWatermark(9);
                        }
                        break;
                    default:
                        // 数字键选择水印
                        if (!isCtrl && !isAlt && /^[1-9]$/.test(key)) {
                            event.preventDefault();
                            selectWatermark(parseInt(key) - 1);
                        }
                        break;

                    // 撤销/重做
                    case 'z':
                        if (isCtrl) {
                            event.preventDefault();
                            if (isShift) {
                                redo();
                            } else {
                                undo();
                            }
                        }
                        break;
                }
            });
           
            // 折叠水印库管理
            const coll = document.getElementsByClassName('collapsible');
        // 绑定事件监听器到每个可折叠元素
        for (let i = 0; i < coll.length; i++) {
            coll[i].addEventListener('click', function (event) {
                if (event.target === this) {
                    this.classList.toggle('active');
                    const content = this.nextElementSibling;
                    
                    if (content.classList.contains('show')) {
                        content.classList.remove('show');
                        content.style.maxHeight = null; // 关闭时重置
                    } else {
                        content.classList.add('show');
                        content.style.maxHeight = content.scrollHeight + "px"; // 打开时平滑调整高度
                    }
                }
            });
        }

            // 初始化 SortableJS
            const watermarkListDiv = document.getElementById('watermark-list');
            const sortable = new Sortable(watermarkListDiv, {
                animation: 150,
                onEnd: function (evt) {
                    let watermarks = JSON.parse(localStorage.getItem('watermarks')) || [];
                    const movedItem = watermarks.splice(evt.oldIndex, 1)[0];
                    watermarks.splice(evt.newIndex, 0, movedItem);
                    localStorage.setItem('watermarks', JSON.stringify(watermarks));
                    updateWatermarkList();
                }
            });

            // 水印库管理相关函数
            document.getElementById('upload-watermark-button').addEventListener('click', () => {
                document.getElementById('watermark-upload-input').click();
            });

            document.getElementById('watermark-upload-input').addEventListener('change', function() {
                const file = this.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            // 检查是否需要去除背景
                            const processedImgDataUrl = removeBackground(img);
                            saveWatermark(processedImgDataUrl);
                            updateWatermarkList();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            function removeBackground(img) {
                // 创建临时 Canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                // 获取图像数据
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // 假设背景为纯白色，设置透明度为0
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] > 240 && data[i + 1] > 240 && data[i + 2] > 240) {
                        data[i + 3] = 0;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL('image/png');
            }

            function saveWatermark(dataUrl) {
                let watermarks = JSON.parse(localStorage.getItem('watermarks')) || [];
                watermarks.push(dataUrl);
                localStorage.setItem('watermarks', JSON.stringify(watermarks));
            }

            function updateWatermarkList() {
                const watermarkListDiv = document.getElementById('watermark-list');
                watermarkListDiv.innerHTML = '';

                let watermarks = JSON.parse(localStorage.getItem('watermarks')) || [];
                const uploadButton = document.getElementById('upload-watermark-button');
                const drawButton = document.getElementById('draw-watermark-button');
                const textButton = document.getElementById('text-watermark-button');

                // 检查签名库是否只有默认的 `signature.png`
                let isDefaultWatermarkOnly = watermarks.length === 0;

                // 如果没有自定义水印，使用默认的 `signature.png`
                if (isDefaultWatermarkOnly) {
                    const defaultWatermark = 'signature.png';
                    const img = new Image();
                    img.src = defaultWatermark;
                    watermarkImages.push(img);
                    watermarks.push(defaultWatermark);
                }

                // 根据签名库状态设置按钮的脉冲效果
                if (isDefaultWatermarkOnly) {
                    // 当只有默认水印时，分别为三个按钮添加脉冲效果
                    uploadButton.classList.add('pulse-effect');
                    drawButton.classList.add('pulse-effect');
                    textButton.classList.add('pulse-effect');
                } else {
                    // 如果有自定义水印，移除脉冲效果
                    uploadButton.classList.remove('pulse-effect');
                    drawButton.classList.remove('pulse-effect');
                    textButton.classList.remove('pulse-effect');
                }

                // 加载水印图片数组
                watermarkImages = watermarks.map(dataUrl => {
                    const img = new Image();
                    img.src = dataUrl;
                    return img;
                });

                // 生成水印列表
                watermarks.forEach((dataUrl, index) => {
                    const watermarkDiv = document.createElement('div');
                    watermarkDiv.className = 'watermark-item';
                    watermarkDiv.setAttribute('data-id', index);

                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.className = 'watermark-thumbnail';
                    watermarkDiv.appendChild(img);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = '删除';
                    deleteButton.addEventListener('click', () => {
                        deleteWatermark(index);
                    });
                    watermarkDiv.appendChild(deleteButton);

                    const downloadButton = document.createElement('button');
                    downloadButton.textContent = '下载';
                    downloadButton.addEventListener('click', () => {
                        downloadWatermark(dataUrl);
                    });
                    watermarkDiv.appendChild(downloadButton);

                    watermarkListDiv.appendChild(watermarkDiv);
                });

                updateWatermarkPreview();
            }

            function deleteWatermark(index) {
                if (confirm('确定要删除该水印吗？')) {
                    let watermarks = JSON.parse(localStorage.getItem('watermarks')) || [];
                    watermarks.splice(index, 1);
                    localStorage.setItem('watermarks', JSON.stringify(watermarks));
                    updateWatermarkList();
                }
            }

            function downloadWatermark(dataUrl) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = 'watermark.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            // 绘制水印功能
            document.getElementById('draw-watermark-button').addEventListener('click', () => {
                showDrawingCanvas();
            });

            function showDrawingCanvas() {
                const modal = document.getElementById('draw-watermark-modal');
                modal.style.display = 'block';

                const canvas = document.getElementById('drawing-canvas');
                const signaturePad = new SignaturePad(canvas);

                document.getElementById('save-drawing-button').addEventListener('click', function() {
                    if (signaturePad.isEmpty()) {
                        alert('请先绘制签名。');
                        return;
                    }
                    const dataUrl = signaturePad.toDataURL('image/png');
                    saveWatermark(dataUrl);
                    updateWatermarkList();
                    signaturePad.clear();
                    modal.style.display = 'none';
                });

                document.getElementById('cancel-drawing-button').addEventListener('click', function() {
                    signaturePad.clear();
                    modal.style.display = 'none';
                });
            }

            // 文字水印功能
            document.getElementById('text-watermark-button').addEventListener('click', () => {
                showTextWatermarkModal();
            });

            function showTextWatermarkModal() {
                const modal = document.getElementById('text-watermark-modal');
                modal.style.display = 'block';

                document.getElementById('save-text-button').addEventListener('click', function() {
                    const text = document.getElementById('text-watermark-input').value.trim();
                    const font = document.getElementById('font-select').value;
                    const fontSize = document.getElementById('font-size-input').value;
                    if (text) {
                        generateTextWatermark(text, font, fontSize);
                        modal.style.display = 'none';
                    } else {
                        alert('请输入文字内容。');
                    }
                });

                document.getElementById('cancel-text-button').addEventListener('click', function() {
                    modal.style.display = 'none';
                });
            }

            function generateTextWatermark(text, fontFamily, fontSize) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.font = `${fontSize}px "${fontFamily}"`;
                ctx.fillStyle = '#000';
                const textWidth = ctx.measureText(text).width;
                canvas.width = textWidth;
                canvas.height = parseInt(fontSize) + 10;
                ctx.font = `${fontSize}px "${fontFamily}"`;
                ctx.fillStyle = '#000';
                ctx.textBaseline = 'top';
                ctx.fillText(text, 0, 0);

                const dataUrl = canvas.toDataURL('image/png');
                saveWatermark(dataUrl);
                updateWatermarkList();
            }

            // 更新水印预览
            function updateWatermarkPreview() {
                const container = document.getElementById('watermark-preview-container');
                container.innerHTML = '';

                let watermarks = JSON.parse(localStorage.getItem('watermarks')) || [];

                // 如果没有水印，使用默认的 signature.png
                if (watermarks.length === 0) {
                    const defaultWatermark = 'signature.png';
                    const img = new Image();
                    img.src = defaultWatermark;
                    watermarkImages.push(img);
                    watermarks.push(defaultWatermark);
                }

                watermarks.forEach((dataUrl, index) => {
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.className = 'watermark-preview';
                    img.addEventListener('click', () => {
                        selectWatermark(index);
                    });
                    if (canvasList[currentIndex] && canvasList[currentIndex].watermarkIndex === index) {
                        img.classList.add('selected');
                    }
                    container.appendChild(img);
                });
            }

            function selectWatermark(index) {
                const params = canvasList[currentIndex];
                const previousIndex = params.watermarkIndex;
                
                // 更新水印索引
                params.watermarkIndex = index;

                // 创建新的水印图像对象
                params.watermarkImage = new Image();
                
                // 设置跨域属性
                params.watermarkImage.crossOrigin = "anonymous";  // 解决跨域问题

                // 设置水印图片的源
                params.watermarkImage.src = watermarkImages[index].src;

                // 确保图像加载完成后更新 Canvas
                params.watermarkImage.onload = function() {
                    // 图像加载完成后执行操作，比如更新当前预览
                    updateCurrentPreview();
                };

                // 如果水印选择不同，记录操作并更新预览
                if (previousIndex !== params.watermarkIndex) {
                    recordAction({
                        type: 'watermarkChange',
                        index: currentIndex,
                        previousParams: { watermarkIndex: previousIndex },
                        newParams: { watermarkIndex: params.watermarkIndex }
                    });
                }

                // 更新水印预览
                updateWatermarkPreview();
            }

            // 更新滑块值显示和参数
            function updateScale() {
                const scaleValue = document.getElementById('scale-slider').value;
                const params = canvasList[currentIndex];
                const previousScale = params.scale;
                params.scale = parseInt(scaleValue) / 100;
                updateCurrentPreview();
                recordAction({
                    type: 'scaleChange',
                    index: currentIndex,
                    previousParams: { scale: previousScale }
                });
            }

            function updateRotation() {
                const rotationValue = document.getElementById('rotation-slider').value;
                const params = canvasList[currentIndex];
                const previousRotation = params.rotation;
                params.rotation = parseInt(rotationValue);
                updateCurrentPreview();
                recordAction({
                    type: 'rotationChange',
                    index: currentIndex,
                    previousParams: { rotation: previousRotation }
                });
            }

            function updateOffsetX() {
                const offsetXValue = document.getElementById('offset-x-slider').value;
                const params = canvasList[currentIndex];
                const previousOffsetX = params.offsetX;
                params.offsetX = parseInt(offsetXValue);
                updateCurrentPreview();
                recordAction({
                    type: 'offsetXChange',
                    index: currentIndex,
                    previousParams: { offsetX: previousOffsetX }
                });
            }

            function updateOffsetY() {
                const offsetYValue = document.getElementById('offset-y-slider').value;
                const params = canvasList[currentIndex];
                const previousOffsetY = params.offsetY;
                params.offsetY = parseInt(offsetYValue);
                updateCurrentPreview();
                recordAction({
                    type: 'offsetYChange',
                    index: currentIndex,
                    previousParams: { offsetY: previousOffsetY }
                });
            }

            function updateOpacity() {
                const opacityValue = document.getElementById('opacity-slider').value;
                const params = canvasList[currentIndex];
                const previousOpacity = params.opacity;
                params.opacity = parseInt(opacityValue) / 100;
                updateCurrentPreview();
                recordAction({
                    type: 'opacityChange',
                    index: currentIndex,
                    previousParams: { opacity: previousOpacity }
                });
            }

            function updatePosition() {
                const params = canvasList[currentIndex];
                const previousPosition = params.position;
                params.position = document.getElementById('position-select').value;
                updateCurrentPreview();
                recordAction({
                    type: 'positionChange',
                    index: currentIndex,
                    previousParams: { position: previousPosition }
                });
            }

            function setColorOption(colorHex) {
                const params = canvasList[currentIndex];
                const previousColor = params.colorHex;
                params.colorHex = colorHex;

                // 更新颜色选择器的值
                document.getElementById('color-picker').value = colorHex;

                // 更新按钮的激活状态
                document.getElementById('color-black-button').classList.toggle('active', colorHex.toUpperCase() === '#000000');
                document.getElementById('color-white-button').classList.toggle('active', colorHex.toUpperCase() === '#FFFFFF');

                updateCurrentPreview();
                recordAction({
                    type: 'colorChange',
                    index: currentIndex,
                    previousParams: { colorHex: previousColor }
                });
            }

            function recordAction(action) {
                redoStack = []; // 清空redoStack
                const lastAction = actionHistory[actionHistory.length - 1];
                if (lastAction && lastAction.type === action.type && lastAction.index === action.index) {
                    // 更新上一次操作的参数
                    lastAction.newParams = { ...canvasList[action.index] };
                } else {
                    actionHistory.push({
                        ...action,
                        newParams: { ...canvasList[action.index] }
                    });
                }
            }

            function undo() {
                if (actionHistory.length === 0) {
                    alert('没有可以撤销的操作。');
                    return;
                }
                const lastAction = actionHistory.pop();
                redoStack.push(lastAction); // 将操作放入redoStack

                if (lastAction.type === 'applyAll') {
                    canvasList.forEach((params, index) => {
                        Object.assign(params, lastAction.previousParamsList[index]);
                        drawWatermark(params);
                    });
                } else {
                    const params = canvasList[lastAction.index];
                    Object.assign(params, lastAction.previousParams);
                    drawWatermark(params);
                }

                updateControlsForCurrentIndex();
            }

            function redo() {
                if (redoStack.length === 0) {
                    alert('没有可以还原的操作。');
                    return;
                }
                const action = redoStack.pop();
                actionHistory.push(action); // 将操作重新放入actionHistory

                if (action.type === 'applyAll') {
                    canvasList.forEach((params) => {
                        Object.assign(params, action.newParams);
                        drawWatermark(params);
                    });
                } else {
                    const params = canvasList[action.index];
                    Object.assign(params, action.newParams);
                    drawWatermark(params);
                }

                updateControlsForCurrentIndex();
            }

            function processImages() {
                imageFiles = Array.from(document.getElementById('image-input').files);

                if (imageFiles.length === 0) {
                    alert('请先选择要处理的图片。');
                    return;
                }

                processedImages = [];
                canvasList = [];
                currentIndex = 0;
                actionHistory = [];
                redoStack = [];
                document.querySelector('.swiper-wrapper').innerHTML = '';

                if (swiper) {
                    swiper.destroy(true, true);
                }

                document.getElementById('progress-bar').style.display = 'block';
                document.getElementById('progress-bar-inner').style.width = '0%';

                let defaultWatermark = watermarkImages.length > 0 ? watermarkImages[0] : new Image();
                if (!defaultWatermark.src) defaultWatermark.src = 'signature.png';

                let loadedCount = 0;
                imageFiles.forEach((imageFile, index) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";  // 允许跨域请求
                    img.src = URL.createObjectURL(imageFile);
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        context.drawImage(img, 0, 0, canvas.width, canvas.height);

                        const defaultParams = {
                            canvas: canvas,
                            context: context,
                            img: img,
                            position: document.getElementById('position-select').value,
                            scale: parseInt(document.getElementById('scale-slider').value) / 100,
                            rotation: parseInt(document.getElementById('rotation-slider').value),
                            offsetX: parseInt(document.getElementById('offset-x-slider').value),
                            offsetY: parseInt(document.getElementById('offset-y-slider').value),
                            opacity: parseInt(document.getElementById('opacity-slider').value) / 100,
                            colorHex: document.getElementById('color-picker').value,
                            shadowEnabled: document.getElementById('shadow-checkbox').checked,
                            watermarkIndex: defaultWatermarkIndex,
                            watermarkImage: watermarkImages[defaultWatermarkIndex] || defaultWatermark
                        };

                        autoSelectSignatureColor(context, img, defaultParams);

                        canvasList.push(defaultParams);
                        loadedCount++;
                        const progress = Math.round((loadedCount / imageFiles.length) * 100);
                        document.getElementById('progress-bar-inner').style.width = progress + '%';

                        if (loadedCount === imageFiles.length) {
                            document.getElementById('progress-bar').style.display = 'none';
                            document.getElementById('download-current-button').style.display = 'block';
                            document.getElementById('download-all-button').style.display = 'block';

                            initializeSwiper();
                            showCurrentImage();
                        }
                    };
                });
            }

            function autoSelectSignatureColor(context, img, params) {
                try {
                    const imageData = context.getImageData(0, 0, img.width, img.height);
                    // 颜色匹配逻辑...
                } catch (error) {
                    if (error instanceof DOMException && error.name === "SecurityError") {
                        console.warn("无法执行颜色匹配：画布被跨域图像污染");
                        params.colorHex = "#000000"; // 使用默认颜色
                    }
                }
                // 计算签名尺寸
                const shorterSide = Math.min(img.width, img.height);
                const watermarkSize = shorterSide * params.scale;
                const watermarkWidth = params.watermarkImage.width * params.scale;
                const watermarkHeight = params.watermarkImage.height * params.scale;

                // 计算签名位置
                let positionX, positionY;
                switch (params.position) {
                    case 'bottom-center':
                        positionX = (img.width - watermarkWidth) / 2 + params.offsetX;
                        positionY = img.height - watermarkHeight + params.offsetY;
                        break;
                    case 'bottom-left':
                        positionX = 10 + params.offsetX;
                        positionY = img.height - watermarkHeight + params.offsetY;
                        break;
                    case 'bottom-right':
                        positionX = img.width - watermarkWidth - 10 + params.offsetX;
                        positionY = img.height - watermarkHeight + params.offsetY;
                        break;
                    case 'top-center':
                        positionX = (img.width - watermarkWidth) / 2 + params.offsetX;
                        positionY = 0 + params.offsetY;
                        break;
                    case 'top-left':
                        positionX = 10 + params.offsetX;
                        positionY = 0 + params.offsetY;
                        break;
                    case 'top-right':
                        positionX = img.width - watermarkWidth - 10 + params.offsetX;
                        positionY = 0 + params.offsetY;
                        break;
                }

                // 获取签名区域的图像数据
                const sampleWidth = Math.min(watermarkWidth, img.width - positionX);
                const sampleHeight = Math.min(watermarkHeight, img.height - positionY);

                // 防止取样区域超出图片范围
                if (sampleWidth <= 0 || sampleHeight <= 0) {
                    params.colorHex = '#000000'; // 默认黑色
                    return;
                }

                const imageData = context.getImageData(positionX, positionY, sampleWidth, sampleHeight);
                const data = imageData.data;
                let totalBrightness = 0;
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                    totalBrightness += brightness;
                }
                const averageBrightness = totalBrightness / (data.length / 4);
                if (averageBrightness > 128) {
                    // 背景较亮，使用黑色签名
                    params.colorHex = '#000000';
                } else {
                    // 背景较暗，使用白色签名
                    params.colorHex = '#FFFFFF';
                }
            }

            function drawWatermark(params) {
                const {
                    canvas,
                    context,
                    img,
                    position,
                    scale,
                    rotation,
                    offsetX,
                    offsetY,
                    opacity,
                    colorHex,
                    shadowEnabled,
                    watermarkImage
                } = params;

                // 清空画布并绘制原始图片
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(img, 0, 0, canvas.width, canvas.height);

                // 定义初始比例
                const initialScale = 0.5; // 初始比例为 50%，可以根据需要调整
                const finalScale = scale * initialScale; // 结合用户提供的 scale 值调整

                // 计算缩放后的水印尺寸
                const shorterSide = Math.min(canvas.width, canvas.height);
                const scaleFactor = (shorterSide / watermarkImage.width) * scale;
                const watermarkWidth = watermarkImage.width * scaleFactor;
                const watermarkHeight = watermarkImage.height * scaleFactor;

                // 重新着色水印
                const coloredSignature = recolorSignature(watermarkImage, colorHex);

                // 根据位置设置锚点坐标
                let positionX, positionY;
                const padding_TB = 200; // 上下内边距
                const padding_LR = 200; // 左右内边距

                switch (position) {
                    case 'bottom-center':
                        positionX = canvas.width / 2 + offsetX;
                        positionY = canvas.height - padding_TB + offsetY;
                        break;
                    case 'bottom-left':
                        positionX = padding_LR + offsetX;
                        positionY = canvas.height - padding_TB + offsetY;
                        break;
                    case 'bottom-right':
                        positionX = canvas.width - padding_LR + offsetX;
                        positionY = canvas.height - padding_TB + offsetY;
                        break;
                    case 'top-center':
                        positionX = canvas.width / 2 + offsetX;
                        positionY = padding_TB + offsetY;
                        break;
                    case 'top-left':
                        positionX = padding_LR + offsetX;
                        positionY = padding_TB + offsetY;
                        break;
                    case 'top-right':
                        positionX = canvas.width - padding_LR + offsetX;
                        positionY = padding_TB + offsetY;
                        break;
                    case 'center':
                        positionX = canvas.width / 2 + offsetX;
                        positionY = canvas.height / 2 + offsetY;
                        break;
                }
                context.save();

                // 将绘制基点设置为水印的中心点
                context.translate(positionX, positionY);
                context.rotate(rotation * Math.PI / 180);
                context.scale(scale, scale); // 以几何中心进行缩放
                context.globalAlpha = opacity;

                // 计算绘制水印的起始点，将几何中心对齐
                const drawX = -watermarkWidth / 2;
                const drawY = -watermarkHeight / 2;

                // 添加阴影（如果启用）
                if (shadowEnabled) {
                    context.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    context.shadowBlur = 5;
                    context.shadowOffsetX = 3;
                    context.shadowOffsetY = 3;
                } else {
                    context.shadowColor = 'transparent';
                }

                // 绘制水印
                context.drawImage(coloredSignature, drawX, drawY, watermarkWidth, watermarkHeight);
                context.restore();

                // 如果需要绘制选中框
                if (params.isDragging) {
                    context.save();
                    context.lineWidth = 1;
                    context.strokeStyle = '#00BFFF';
                    context.setLineDash([5, 3]);
                    context.translate(positionX, positionY);
                    context.rotate(rotation * Math.PI / 180);
                    context.strokeRect(drawX, drawY, watermarkWidth, watermarkHeight);
                    context.restore();
                }
            }

            function recolorSignature(watermarkImage, colorHex) {
                const tempCanvas = document.createElement('canvas');
                const tempContext = tempCanvas.getContext('2d');
                tempCanvas.width = watermarkImage.width;
                tempCanvas.height = watermarkImage.height;

                // 填充所选颜色
                tempContext.fillStyle = colorHex;
                tempContext.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // 应用混合模式，将签名形状与颜色合并
                tempContext.globalCompositeOperation = 'destination-in';
                tempContext.drawImage(watermarkImage, 0, 0);

                // 恢复混合模式
                tempContext.globalCompositeOperation = 'source-over';

                return tempCanvas;
            }

            function initializeSwiper() {
                const swiperWrapper = document.querySelector('.swiper-wrapper');
                swiperWrapper.innerHTML = '';

                canvasList.forEach((item, index) => {
                    const slide = document.createElement('div');
                    slide.className = 'swiper-slide';
                    slide.appendChild(item.canvas);
                    swiperWrapper.appendChild(slide);

                    // 初始化手势操作
                    initializeGestures(item, index);
                });

                swiper = new Swiper('.swiper-container', {
                    loop: false,
                    pagination: {
                        el: '.swiper-pagination',
                    },
                    autoHeight: true, // 启用自动高度
                    on: {
                        slideChange: function () {
                            currentIndex = swiper.activeIndex;
                            updateControlsForCurrentIndex();
                            drawWatermark(canvasList[currentIndex]);
                        },
                    },
                });
            }

            function initializeGestures(params, index) {
                const hammertime = new Hammer(params.canvas);
                hammertime.get('pan').set({ direction: Hammer.DIRECTION_ALL });
                hammertime.get('pinch').set({ enable: true });
                hammertime.get('rotate').set({ enable: true });

                let initialScale = params.scale;
                let initialRotation = params.rotation;
                let initialOffsetX = params.offsetX;
                let initialOffsetY = params.offsetY;

                // 移动事件
                hammertime.on('panmove', function(ev) {
                    if (currentIndex !== index) return;
                    params.offsetX = initialOffsetX + ev.deltaX;
                    params.offsetY = initialOffsetY + ev.deltaY;
                    updateControlsForCurrentIndex();
                    drawWatermark(params);
                });

                // 结束移动事件
                hammertime.on('panend', function(ev) {
                    if (currentIndex !== index) return;
                    initialOffsetX = params.offsetX;
                    initialOffsetY = params.offsetY;
                    recordAction({
                        type: 'offsetChange',
                        index: currentIndex,
                        previousParams: {
                            offsetX: initialOffsetX - ev.deltaX,
                            offsetY: initialOffsetY - ev.deltaY
                        }
                    });
                });

                let pinchStart = false;
                hammertime.on('pinchstart', function(ev) {
                    if (currentIndex !== index) return;
                    pinchStart = true;
                    initialScale = params.scale;
                    initialRotation = params.rotation;
                });

                hammertime.on('pinchmove', function(ev) {
                    if (currentIndex !== index || !pinchStart) return;
                    params.scale = initialScale * ev.scale;
                    params.rotation = initialRotation + ev.rotation;
                    updateControlsForCurrentIndex();
                    drawWatermark(params);
                });

                hammertime.on('pinchend', function(ev) {
                    if (currentIndex !== index) return;
                    pinchStart = false;
                    initialScale = params.scale;
                    initialRotation = params.rotation;
                    recordAction({
                        type: 'scaleRotationChange',
                        index: currentIndex,
                        previousParams: {
                            scale: initialScale / ev.scale,
                            rotation: initialRotation - ev.rotation
                        }
                    });
                });

                // 添加鼠标事件监听器
                let isDragging = false;
                let startX, startY;

                params.canvas.addEventListener('mousedown', function(e) {
                    if (currentIndex !== index) return;
                    const rect = params.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // 仅当点击在水印上时启用拖拽
                    if (isPointOnWatermark(x, y, params)) {
                        isDragging = true;
                        startX = x;
                        startY = y;
                        initialOffsetX = params.offsetX;
                        initialOffsetY = params.offsetY;
                        params.isDragging = true;
                    }
                });

                params.canvas.addEventListener('mousemove', function(e) {
                    if (currentIndex !== index) return;
                    if (isDragging) {
                        const rect = params.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const deltaX = x - startX;
                        const deltaY = y - startY;
                        params.offsetX = initialOffsetX + deltaX;
                        params.offsetY = initialOffsetY + deltaY;
                        updateControlsForCurrentIndex();
                        drawWatermark(params);
                    }
                });

                params.canvas.addEventListener('mouseup', function(e) {
                    if (currentIndex !== index) return;
                    if (isDragging) {
                        isDragging = false;
                        params.isDragging = false;

                        // 更新初始偏移量
                        initialOffsetX = params.offsetX;
                        initialOffsetY = params.offsetY;

                        // 记录操作
                        recordAction({
                            type: 'offsetChange',
                            index: currentIndex,
                            previousParams: {
                                offsetX: initialOffsetX,
                                offsetY: initialOffsetY
                            }
                        });
                    }
                });

                params.canvas.addEventListener('mouseleave', function(e) {
                    if (currentIndex !== index) return;
                    if (isDragging) {
                        isDragging = false;
                        params.isDragging = false;
                    }
                });
            }       

            function isPointOnWatermark(x, y, params) {
                const { positionX, positionY, watermarkWidth, watermarkHeight } = calculateWatermarkPosition(params);

                // 中心点与点击点的相对位置
                const centerX = positionX + watermarkWidth / 2;
                const centerY = positionY + watermarkHeight / 2;
                const dx = x - centerX;
                const dy = y - centerY;

                // 考虑旋转角度，将点击点旋转回水印未旋转状态
                const angle = -params.rotation * Math.PI / 180;
                const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
                const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);

                // 检查旋转后的点是否在水印矩形范围内
                return Math.abs(rotatedX) <= watermarkWidth / 2 && Math.abs(rotatedY) <= watermarkHeight / 2;
            }

            function calculateWatermarkPosition(params) {
                const {
                    canvas,
                    position,
                    scale,
                    offsetX,
                    offsetY,
                    watermarkImage
                } = params;

                const shorterSide = Math.min(canvas.width, canvas.height);
                const scaleFactor = (shorterSide / watermarkImage.width) * scale;
                const watermarkWidth = watermarkImage.width * scaleFactor;
                const watermarkHeight = watermarkImage.height * scaleFactor;

                let positionX, positionY;
                switch (position) {
                    case 'bottom-center':
                        positionX = (canvas.width - watermarkWidth) / 2 + offsetX;
                        positionY = canvas.height - watermarkHeight + offsetY;
                        break;
                    case 'bottom-left':
                        positionX = 10 + offsetX;
                        positionY = canvas.height - watermarkHeight + offsetY;
                        break;
                    case 'bottom-right':
                        positionX = canvas.width - watermarkWidth - 10 + offsetX;
                        positionY = canvas.height - watermarkHeight + offsetY;
                        break;
                    case 'top-center':
                        positionX = (canvas.width - watermarkWidth) / 2 + offsetX;
                        positionY = 0 + offsetY;
                        break;
                    case 'top-left':
                        positionX = 10 + offsetX;
                        positionY = 0 + offsetY;
                        break;
                    case 'top-right':
                        positionX = canvas.width - watermarkWidth - 10 + offsetX;
                        positionY = 0 + offsetY;
                        break;
                }

                return { positionX, positionY, watermarkWidth, watermarkHeight };
            }
            function showCurrentImage() {
                swiper.slideTo(currentIndex, 0);
                updateControlsForCurrentIndex();
                drawWatermark(canvasList[currentIndex]);
            }

            function updateControlsForCurrentIndex() {
                const params = canvasList[currentIndex];

                document.getElementById('position-select').value = params.position;
                document.getElementById('scale-slider').value = params.scale * 100;
                document.getElementById('scale-input').value = Math.round(params.scale * 100);
                document.getElementById('rotation-slider').value = params.rotation;
                document.getElementById('rotation-input').value = Math.round(params.rotation);
                document.getElementById('offset-x-slider').value = params.offsetX;
                document.getElementById('offset-x-input').value = Math.round(params.offsetX);
                document.getElementById('offset-y-slider').value = params.offsetY;
                document.getElementById('offset-y-input').value = Math.round(params.offsetY);
                document.getElementById('opacity-slider').value = params.opacity * 100;
                document.getElementById('opacity-input').value = params.opacity * 100;

                // 更新颜色选择器和按钮状态
                document.getElementById('color-picker').value = params.colorHex;
                document.getElementById('color-black-button').classList.toggle(
                    'active',
                    params.colorHex && params.colorHex.toUpperCase() === '#000000'
                );
                document.getElementById('color-white-button').classList.toggle(
                    'active',
                    params.colorHex && params.colorHex.toUpperCase() === '#FFFFFF'
                );
                // 更新阴影复选框
                document.getElementById('shadow-checkbox').checked = params.shadowEnabled;

                // 更新水印预览选中状态
                updateWatermarkPreview();
            }

            function updateCurrentPreview() {
                const params = canvasList[currentIndex];
                drawWatermark(params);
            }

            function applyPreviousSettings() {
                if (currentIndex === 0) {
                    alert('当前是第一张照片，没有上一张照片的设置可用。');
                    return;
                }
                const previousParams = { ...canvasList[currentIndex - 1] };
                const currentParams = canvasList[currentIndex];

                // 记录当前参数用于撤销
                const previousState = { ...currentParams };

                // 复制参数（避免复制canvas, context等对象）
                currentParams.position = previousParams.position;
                currentParams.scale = previousParams.scale;
                currentParams.rotation = previousParams.rotation;
                currentParams.offsetX = previousParams.offsetX;
                currentParams.offsetY = previousParams.offsetY;
                currentParams.opacity = previousParams.opacity;
                currentParams.colorHex = previousParams.colorHex;
                currentParams.shadowEnabled = previousParams.shadowEnabled;
                currentParams.watermarkIndex = previousParams.watermarkIndex;
                currentParams.watermarkImage = previousParams.watermarkImage;

                // 更新控件和预览
                updateControlsForCurrentIndex();
                drawWatermark(currentParams);

                // 记录用户操作
                actionHistory.push({
                    type: 'applyPrevious',
                    index: currentIndex,
                    previousParams: previousState,
                    newParams: { ...currentParams }
                });
            }

            function applyToAll() {
                const currentParams = canvasList[currentIndex];
                const previousParamsList = canvasList.map(params => ({ ...params }));

                document.getElementById('progress-bar').style.display = 'block';
                document.getElementById('progress-bar-inner').style.width = '0%';

                let processedCount = 0;
                canvasList.forEach((params, index) => {
                    if (index !== currentIndex) {
                        Object.assign(params, {
                            position: currentParams.position,
                            scale: currentParams.scale,
                            rotation: currentParams.rotation,
                            offsetX: currentParams.offsetX,
                            offsetY: currentParams.offsetY,
                            opacity: currentParams.opacity,
                            colorHex: currentParams.colorHex,
                            shadowEnabled: currentParams.shadowEnabled,
                            watermarkIndex: currentParams.watermarkIndex,
                            watermarkImage: currentParams.watermarkImage
                        });
                        drawWatermark(params);
                    }
                    processedCount++;
                    // 更新进度条
                    const progress = Math.round((processedCount / canvasList.length) * 100);
                    document.getElementById('progress-bar-inner').style.width = progress + '%';

                    if (processedCount === canvasList.length) {
                        document.getElementById('progress-bar').style.display = 'none';
                    }
                });

                // 记录用户操作
                actionHistory.push({
                    type: 'applyAll',
                    previousParamsList: previousParamsList,
                    newParams: { ...currentParams }
                });

                redoStack = []; // 清空redoStack
            }

            function savePreset() {
                let presetName = document.getElementById('preset-name-input').value.trim();
                if (!presetName) {
                    const now = new Date();
                    presetName = `预设_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}${now.getSeconds().toString().padStart(2,'0')}`;
                }
                const params = canvasList[currentIndex];
                const presetData = {
                    position: params.position,
                    scale: params.scale,
                    rotation: params.rotation,
                    offsetX: params.offsetX,
                    offsetY: params.offsetY,
                    opacity: params.opacity,
                    colorHex: params.colorHex,
                    shadowEnabled: params.shadowEnabled,
                    watermarkIndex: params.watermarkIndex
                };
                localStorage.setItem('preset_' + presetName, JSON.stringify(presetData));
                alert(`预设已保存为 "${presetName}"。`);
                updatePresetList();
            }

            function updatePresetList() {
                const presetSelect = document.getElementById('preset-select');
                presetSelect.innerHTML = '<option value="">选择预设</option>';
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('preset_')) {
                        const presetName = key.replace('preset_', '');
                        const option = document.createElement('option');
                        option.value = presetName;
                        option.textContent = presetName;
                        presetSelect.appendChild(option);
                    }
                }
            }

            function loadPreset() {
                const presetName = document.getElementById('preset-select').value;
                if (!presetName) {
                    alert('请先选择预设。');
                    return;
                }
                const presetData = JSON.parse(localStorage.getItem('preset_' + presetName));
                applyPreset(presetData);
            }

            function deletePreset() {
                const presetName = document.getElementById('preset-select').value;
                if (!presetName) {
                    alert('请先选择要删除的预设。');
                    return;
                }
                if (confirm(`确定要删除预设 "${presetName}" 吗？`)) {
                    localStorage.removeItem('preset_' + presetName);
                    updatePresetList();
                    alert('预设已删除。');
                }
            }

            function applyPreset(presetData) {
                const params = canvasList[currentIndex];
                const previousParams = { ...params };

                // 应用预设
                params.position = presetData.position || params.position;
                params.scale = presetData.scale || params.scale;
                params.rotation = presetData.rotation || params.rotation;
                params.offsetX = presetData.offsetX || params.offsetX;
                params.offsetY = presetData.offsetY || params.offsetY;
                params.opacity = presetData.opacity || params.opacity;
                params.colorHex = presetData.colorHex || params.colorHex;
                params.shadowEnabled = presetData.shadowEnabled !== undefined ? presetData.shadowEnabled : params.shadowEnabled;
                params.watermarkIndex = presetData.watermarkIndex !== undefined ? presetData.watermarkIndex : params.watermarkIndex;
                params.watermarkImage = watermarkImages[params.watermarkIndex];

                // 更新控件和预览
                updateControlsForCurrentIndex();
                drawWatermark(params);

                // 记录用户操作
                actionHistory.push({
                    type: 'applyPreset',
                    index: currentIndex,
                    previousParams: previousParams,
                    newParams: { ...params }
                });

                redoStack = []; // 清空redoStack
            }

            function exportPreset() {
                const presets = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('preset_')) {
                        const presetName = key.replace('preset_', '');
                        const presetData = JSON.parse(localStorage.getItem(key));
                        presets[presetName] = presetData;
                    }
                }
                const blob = new Blob([JSON.stringify(presets)], { type: 'application/json' });
                const now = new Date();
                const fileName = `预设_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}${now.getSeconds().toString().padStart(2,'0')}.json`;
                saveAs(blob, fileName);
            }

            function importPreset(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedPresets = JSON.parse(e.target.result);
                            for (const presetName in importedPresets) {
                                localStorage.setItem('preset_' + presetName, JSON.stringify(importedPresets[presetName]));
                            }
                            updatePresetList();
                            alert('预设已成功导入。');
                        } catch (error) {
                            alert('导入失败，请确保文件格式正确。');
                        }
                    };
                    reader.readAsText(file);
                }
            }
            
            function applyToAll() {
                // 询问用户是否希望优先使用自动匹配颜色
                const useAutoColorMatch = confirm("是否要优先使用自动匹配颜色？");

                const currentParams = canvasList[currentIndex];
                const previousParamsList = canvasList.map(params => ({ ...params }));

                document.getElementById('progress-bar').style.display = 'block';
                document.getElementById('progress-bar-inner').style.width = '0%';

                let processedCount = 0;
                canvasList.forEach((params, index) => {
                    if (index !== currentIndex) {
                        Object.assign(params, {
                            position: currentParams.position,
                            scale: currentParams.scale,
                            rotation: currentParams.rotation,
                            offsetX: currentParams.offsetX,
                            offsetY: currentParams.offsetY,
                            opacity: currentParams.opacity,
                            colorHex: useAutoColorMatch ? autoSelectSignatureColor(params.context, params.img, params) : currentParams.colorHex,
                            shadowEnabled: currentParams.shadowEnabled,
                            watermarkIndex: currentParams.watermarkIndex,
                            watermarkImage: currentParams.watermarkImage
                        });
                        drawWatermark(params);
                    }
                    processedCount++;
                    // 更新进度条
                    const progress = Math.round((processedCount / canvasList.length) * 100);
                    document.getElementById('progress-bar-inner').style.width = progress + '%';

                    if (processedCount === canvasList.length) {
                        document.getElementById('progress-bar').style.display = 'none';
                    }
                });

                // 记录用户操作
                actionHistory.push({
                    type: 'applyAll',
                    previousParamsList: previousParamsList,
                    newParams: { ...currentParams }
                });

                redoStack = []; // 清空redoStack
            }

            // 初始化时更新预设列表
            updatePresetList();

            function downloadCurrentImage() {
                const params = canvasList[currentIndex];
                drawWatermark(params);

                params.canvas.toBlob((blob) => {
                    if (!blob) {
                        alert('生成图片失败，请重试。');
                        return;
                    }
                    let originalName = imageFiles[currentIndex].name;
                    let fileName = originalName.replace(/(\.\w+)$/, '_WaterMark$1');
                    fileName = sanitizeFileName(fileName);
                    let version = 1;

                    // 模拟文件名冲突处理
                    while (processedImages.includes(fileName)) {
                        version++;
                        fileName = originalName.replace(/(\.\w+)$/, `_WaterMark_v${version}$1`);
                        fileName = sanitizeFileName(fileName);
                    }

                    processedImages.push(fileName);

                    saveAs(blob, fileName);
                }, 'image/jpeg', 0.95);
            }

            function downloadAllImages() {
                if (canvasList.length === 0) {
                    alert('没有可下载的图片。');
                    return;
                }

                const zip = new JSZip();  // 创建一个新的 Zip 文件
                const folderName = 'watermarked_images';
                const imgFolder = zip.folder(folderName);  // 在 Zip 文件中创建一个文件夹

                let processedCount = 0;  // 计数器，用于计算已处理的文件
                document.getElementById('progress-bar').style.display = 'block';  // 显示进度条
                document.getElementById('progress-bar-inner').style.width = '0%';  // 初始化进度条

                let fileNameCounts = {};  // 用于处理文件名冲突的计数器

                canvasList.forEach((item, index) => {
                    // 处理每个 canvas，生成图像二进制数据
                    drawWatermark(item);  // 绘制水印
                    item.canvas.toBlob((blob) => {
                        if (!blob) {
                            alert('生成图片失败，请重试。');
                            return;
                        }

                        const imageFile = imageFiles[index];  // 获取对应的图片文件
                        let originalName = imageFile.name;
                        let fileName = originalName.replace(/(\.\w+)$/, '_WaterMark$1');  // 添加 _WaterMark 后缀
                        fileName = sanitizeFileName(fileName);  // 清理文件名中的非法字符

                        // 处理文件名冲突
                        if (fileNameCounts[fileName]) {
                            fileNameCounts[fileName]++;
                            const version = fileNameCounts[fileName];  // 版本号
                            fileName = originalName.replace(/(\.\w+)$/, `_WaterMark_v${version}$1`);
                            fileName = sanitizeFileName(fileName);  // 清理文件名
                        } else {
                            fileNameCounts[fileName] = 1;
                        }

                        imgFolder.file(fileName, blob);  // 将图像添加到 Zip 文件中
                        processedCount++;  // 增加计数器

                        // 更新进度条
                        const progress = Math.round((processedCount / canvasList.length) * 100);
                        document.getElementById('progress-bar-inner').style.width = progress + '%';

                        // 如果所有图像都已处理完，生成并下载 Zip 文件
                        if (processedCount === canvasList.length) {
                            document.getElementById('progress-bar').style.display = 'none';
                            zip.generateAsync({ type: 'blob' }).then((content) => {
                                saveAs(content, folderName + '.zip');  // 下载 Zip 文件
                            });
                        }
                    }, 'image/jpeg', 1.00);  // 使用 JPEG 格式并压缩质量为 95%
                });
            }

            // 清理文件名中的非法字符
            function sanitizeFileName(fileName) {
                return fileName.replace(/[\/\\:*?"<>|]/g, '_');  // 将非法字符替换为下划线
            }
    </script>
</body>
</html>
